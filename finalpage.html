<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Spyfall Game - Playing</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link href="custom/custom.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">

    <style>
      body {
        padding: 20px;
        padding-top: 80px; /* Account for ad banner */
        background-image: url(./gallary/background-motion.png);
        background-size: cover;
        background-repeat: no-repeat;
        background-position: center center;
        transition: background-image 1s ease-in-out;
      }

      .text-center h3 {
        font-family: "AbdoMaster";
        font-size: 40px;
        color: #fff;
        line-height: 65px;
      }

      .player-box {
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 5px 10px;
        display: inline-flex;
        align-items: center;
        margin: 2px;
        font-family: "AbdoMaster";
        color: #fff;
        text-align: center;
        margin: 0 auto;
        width: fit-content;
        width: 100%;
        display: flex;
        justify-content: center;
      }

      .host-number {
        font-weight: bold;
        color: #ffcc00;
        margin-right: 5px;
        display: none !important;
      }

      .guess-option {
        margin-bottom: 10px;
        width: 100%;
      }

      .waiting-text {
        color: white !important;
        font-style: italic;
        font-family: "AbdoMaster";
        font-size: 16px;
        text-align: center;
        margin: 0 auto;
        margin-top: 15px; /* Increased gap for better spacing */
      }

      .ad-content {
        color: white;
        font-weight: bold;
        font-size: 16px;
        text-align: center;
      }

      .ad-text {
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      /* Points Dashboard Styles */
      .points-dashboard {
        position: fixed;
        top: 70px;
        right: 10px;
        width: 200px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        z-index: 999;
        overflow: hidden;
      }

      .dashboard-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 8px 12px;
        font-weight: bold;
        font-size: 14px;
        text-align: center;
      }

      .dashboard-title {
        font-size: 12px;
      }

      .points-container {
        padding: 10px;
        max-height: 200px;
        overflow-y: auto;
      }

      .player-score {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 6px 8px;
        margin: 3px 0;
        background: #f8f9fa;
        border-radius: 8px;
        font-size: 12px;
        color: #333;
        transition: all 0.3s ease;
      }

      .player-score:hover {
        background: #e9ecef;
        transform: translateX(3px);
      }

      .player-name {
        font-weight: bold;
        max-width: 120px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .player-points {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-weight: bold;
        font-size: 11px;
      }

      /* Top 3 Styles */
      .first-place .player-name::before {
        content: "ü•á ";
      }

      .first-place {
        background: linear-gradient(135deg, #ffd700 0%, #ffcc00 100%);
        color: #333;
      }

      .second-place .player-name::before {
        content: "ü•à ";
      }

      .second-place {
        background: linear-gradient(135deg, #c0c0c0 0%, #a9a9a9 100%);
        color: #333;
      }

      .third-place .player-name::before {
        content: "ü•â ";
      }

      .third-place {
        background: linear-gradient(135deg, #cd7f32 0%, #b87333 100%);
        color: #333;
      }

      /* Notification System Styles */
      .notification-container {
        position: fixed;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 998;
        width: 90%;
        max-width: 400px;
      }

      .notification {
        background: rgba(255, 255, 255, 0.95);
        border-left: 4px solid #667eea;
        padding: 12px 16px;
        margin: 8px 0;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        animation: slideInDown 0.5s ease, fadeOut 0.5s ease 4.5s forwards;
        color: #333;
        font-weight: 500;
      }

      .notification.success {
        border-left-color: #28a745;
        background: rgba(212, 237, 218, 0.95);
      }

      .notification.info {
        border-left-color: #17a2b8;
        background: rgba(209, 236, 241, 0.95);
      }

      .notification.warning {
        border-left-color: #ffc107;
        background: rgba(255, 243, 205, 0.95);
      }

      @keyframes slideInDown {
        from {
          opacity: 0;
          transform: translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes fadeOut {
        to {
          opacity: 0;
          transform: translateY(-20px);
        }
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .points-dashboard {
          width: 180px;
          right: 5px;
        }

        .dashboard-title {
          font-size: 11px;
        }

        .player-score {
          font-size: 11px;
        }

        .notification-container {
          width: 95%;
        }

        .ad-banner {
          height: 50px;
        }

        .ad-content {
          font-size: 14px;
        }
      }

      @media (max-width: 480px) {
        .points-dashboard {
          width: 160px;
          top: 60px;
        }

        .player-name {
          max-width: 100px;
        }
      }

      /* Enhanced Progress Styles */
      .progress-text {
        font-family: "AbdoMaster";
        font-size: 24px;
        color: #fff;
        font-weight: bold;
        margin-bottom: 10px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center;
      }

      .question-header {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-bottom: 15px;
        gap: 15px; /* Added gap between question, selected player, and instruction */
      }

      .question-header h5 {
        font-family: "AbdoMaster";
        font-size: 28px;
        color: white !important;
        margin: 0;
        display: none;
      }

      .question-header p {
        font-family: "AbdoMaster";
        font-size: 20px;
        color: white !important;
        margin: 0;
      }
    </style>
  </head>

  <body>
    <script>
      const defaultBackgrounds = [
        "gallary/picture/1.PNG",
        "gallary/picture/2.PNG",
        "gallary/picture/3.PNG",
        "gallary/picture/4.PNG",
        "gallary/picture/5.PNG",
        "gallary/picture/6.PNG",
        "gallary/picture/7.PNG",
        "gallary/picture/8.PNG",
        "gallary/picture/9.PNG",
        "gallary/picture/10.PNG",
        "gallary/picture/11.PNG",
        "gallary/picture/12.PNG",
        "gallary/picture/13.PNG",
        "gallary/picture/14.PNG",
        "gallary/picture/15.PNG",
        "gallary/picture/16.PNG",
        "gallary/picture/17.PNG",
        "gallary/picture/18.PNG",
      ];

      document.addEventListener("DOMContentLoaded", function () {
        const selectedBg =
          defaultBackgrounds[
            Math.floor(Math.random() * defaultBackgrounds.length)
          ];
        document.body.style.backgroundImage = `url('${selectedBg}')`;
      });
    </script>
    <!-- Top Ad Banner -->
    <div id="adBanner" class="ad-banner">
      <div class="ad-content">
        <span class="ad-text"></span>
      </div>
    </div>

    <!-- Points Dashboard -->
    <div id="pointsDashboard" class="points-dashboard">
      <div class="dashboard-header">
        <span class="dashboard-title" id="dashboardTitle">üèÜ Rewards</span>
      </div>
      <div id="pointsContainer" class="points-container"></div>
    </div>

    <!-- Notification System -->
    <div id="notificationContainer" class="notification-container"></div>

    <div class="container text-center">
      <img src="gallary/name-12.png" class="img-fluid" alt="img" />
      <p><span id="timer">00:00</span></p>
      <p id="roundProgress" class="btn btn-success mb-2"></p>
      <p id="turnProgress" class="progress-text mb-2"></p>
      <h3 id="waitingHeader" style="display: none"></h3>
      <h3 id="chooseHeader"></h3>
      <div id="questionSectionprime"></div>

      <div id="optionsContainer" class="mb-3"></div>

      <button id="submitAnswerBtn" class="btn btn-success mb-2 d-none"></button>
      <button id="nextRoundBtn" class="btn btn-success mb-2 d-none"></button>
      <h5 id="playersHeader">Players</h5>
      <div
        id="playersContainer"
        class="d-flex flex-wrap justify-content-center"
      ></div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-database-compat.js"></script>

    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyAXUdqcAfldO1YuxlKDWCh7EYo2nO4AMog",
        authDomain: "spyfall-fb59a.firebaseapp.com",
        projectId: "spyfall-fb59a",
        storageBucket: "spyfall-fb59a.firebasestorage.app",
        messagingSenderId: "125069847545",
        appId: "1:125069847545:web:faa43c6e58db9df7242b28",
        measurementId: "G-MFV3SETE0D",
        databaseURL: "https://spyfall-fb59a-default-rtdb.firebaseio.com",
      };

      firebase.initializeApp(firebaseConfig);
      const database = firebase.database();

      const urlParams = new URLSearchParams(window.location.search);
      const accessCode = urlParams.get("code") || "testcode";
      const savedPlayerName = localStorage.getItem("playerName") || "Player";
      const gameRef = database.ref("games/" + accessCode);

      const questionSectionprime = document.getElementById(
        "questionSectionprime"
      );
      const optionsContainer = document.getElementById("optionsContainer");
      const submitAnswerBtn = document.getElementById("submitAnswerBtn");
      const nextRoundBtn = document.getElementById("nextRoundBtn");
      const pointsContainer = document.getElementById("pointsContainer");
      const roundProgress = document.getElementById("roundProgress");
      const turnProgress = document.getElementById("turnProgress");
      const waitingHeader = document.getElementById("waitingHeader");
      const chooseHeader = document.getElementById("chooseHeader");
      const playersHeader = document.getElementById("playersHeader");
      const dashboardTitle = document.getElementById("dashboardTitle");

      let globalTimerInterval;
      let questionLimit;
      let currentRoundNumber = 0;
      let currentTurnNumber = 1;
      let playerCount = 0;
      let totalQuestionCount = 0;
      let gameStartTime = null;
      let gameDuration = 0;
      let language = "en"; // Default language

      let selectedOption = null;
      let hostName = "";
      let questionLimitLoaded = false;

      let simpleQuestions = [];
      let sponsoredQuestions = [];
      let sponsoredAds = [];
      let questionsLoaded = false;
      let currentAds = [];
      let currentAdIndex = 0;
      let questionSequence = [];
      let usedSimpleQuestions = [];
      let usedSponsoredQuestions = [];
      let playerOrder = [];
      let roundTargetPlayers = [];

      // Translation object for UI text
      const translations = {
        en: {
          dashboardTitle: "üèÜ Rewards",
          playersHeader: "Players",
          chooseHeader: "Choose an option",
          waitingHeader: "Waiting for {selectedPlayer} to choose...",
          waitingTextSelected: "Choose your answer...",
          waitingTextOthers: "Waiting for {selectedPlayer} to choose...",
          waitingTextComplete:
            "Action complete. Waiting for host to proceed...",
          submitAnswerBtn: "Submit Answer",
          nextRoundBtn: "Next Round",
          roundProgress: "Question {currentRound}/{totalRounds}",
          notifications: {
            chooseOption: "Choose an option",
            noAnswerSelected: "You did not select an answer for this action.",
            correctGuess: "{player} guessed correctly! +1 point",
            wrongGuess: "Your guess was wrong.",
            noGuessSubmitted: "You did not submit a guess.",
            selectedPlayerComplete: "Your turn as Selected Player is complete.",
            errorUpdatingPoints: "Error updating points for {player}.",
            errorNotifications:
              "Error updating notifications. Please try again.",
            errorActionData:
              "Error initializing action data. Please try again.",
            errorActionInit: "Error starting action. Please try again.",
            errorActionAdvance:
              "Error advancing to next action. Please try again.",
            errorRoundAdvance:
              "Error advancing to next round. Please try again.",
            errorRoundAdvanceRetries:
              "Error advancing to next round after multiple attempts. Please check your connection or try again.",
            errorSubmissions: "Error monitoring submissions. Please try again.",
            minPlayers: "Minimum 2 players required to start the game.",
            minPlayersContinue:
              "Minimum 2 players required to continue the game.",
            noQuestions:
              "No valid questions with options available. Game ended.",
            notEnoughQuestions:
              "Not enough questions for {totalRounds} rounds with {playerCount} players",
            gameInitError: "Error initializing game.",
            gameDataError: "Error loading game data.",
            timeUp: "Time's up! Game ended.",
            roundsComplete: "All {totalRounds} rounds completed! Game ended.",
            invalidPlayerData:
              "Error: Invalid player data for next round. Please try again.",
          },
        },
        ar: {
          dashboardTitle: "üèÜ ÿßŸÑŸÖŸÉÿßŸÅÿ¢ÿ™",
          playersHeader: "ÿßŸÑŸÑÿßÿπÿ®ŸàŸÜ",
          chooseHeader: "ÿßÿÆÿ™ÿ± ÿÆŸäÿßÿ±Ÿãÿß",
          waitingHeader: "ŸÅŸä ÿßŸÜÿ™ÿ∏ÿßÿ± {selectedPlayer} ÿßÿÆÿ™ÿ± ÿÆŸäÿßÿ±Ÿãÿß",
          waitingTextSelected: "ÿßÿÆÿ™ÿ± ÿ•ÿ¨ÿßÿ®ÿ™ŸÉ...",
          waitingTextOthers: "ŸÅŸä ÿßŸÜÿ™ÿ∏ÿßÿ± {selectedPlayer} ŸÑŸäÿÆÿ™ÿßÿ±...",
          waitingTextComplete: "ÿßŸÉÿ™ŸÖŸÑ ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°. ŸÅŸä ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßŸÑŸÖÿ∂ŸäŸÅ ŸÑŸÑŸÖÿ™ÿßÿ®ÿπÿ©...",
          submitAnswerBtn: "ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©",
          nextRoundBtn: "ÿßŸÑÿ¨ŸàŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©",
          roundProgress: "ÿßŸÑÿ≥ÿ§ÿßŸÑ {currentRound}/{totalRounds}",
          notifications: {
            chooseOption: "ÿßÿÆÿ™ÿ± ÿÆŸäÿßÿ±Ÿãÿß",
            noAnswerSelected: "ŸÑŸÖ ÿ™ÿÆÿ™ÿßÿ± ÿ•ÿ¨ÿßÿ®ÿ© ŸÑŸáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°.",
            correctGuess: "{player} ÿÆŸÖŸÜ ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠! +1 ŸÜŸÇÿ∑ÿ©",
            wrongGuess: "ÿ™ÿÆŸÖŸäŸÜŸÉ ŸÉÿßŸÜ ÿÆÿßÿ∑ÿ¶Ÿãÿß.",
            noGuessSubmitted: "ŸÑŸÖ ÿ™ŸÇÿØŸÖ ÿ™ÿÆŸÖŸäŸÜŸãÿß.",
            selectedPlayerComplete: "ÿßŸÜÿ™ŸáŸâ ÿØŸàÿ±ŸÉ ŸÉŸÑÿßÿπÿ® ŸÖÿÆÿ™ÿßÿ±.",
            errorUpdatingPoints: "ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÑŸÄ {player}.",
            errorNotifications: "ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
            errorActionData: "ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ŸáŸäÿ¶ÿ© ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
            errorActionInit: "ÿÆÿ∑ÿ£ ŸÅŸä ÿ®ÿØÿ° ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
            errorActionAdvance:
              "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿ•ŸÑŸâ ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑÿ™ÿßŸÑŸä. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
            errorRoundAdvance:
              "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿ•ŸÑŸâ ÿßŸÑÿ¨ŸàŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
            errorRoundAdvanceRetries:
              "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿ•ŸÑŸâ ÿßŸÑÿ¨ŸàŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ© ÿ®ÿπÿØ ÿπÿØÿ© ŸÖÿ≠ÿßŸàŸÑÿßÿ™. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ™ÿµÿßŸÑŸÉ Ÿàÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
            errorSubmissions: "ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿ±ÿßŸÇÿ®ÿ© ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑÿßÿ™. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
            minPlayers: "Ÿäÿ™ÿ∑ŸÑÿ® ÿßŸÑÿ£ŸÖÿ± ŸÑÿßÿπÿ®ŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ŸÑÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®ÿ©.",
            minPlayersContinue: "Ÿäÿ™ÿ∑ŸÑÿ® ÿßŸÑÿ£ŸÖÿ± ŸÑÿßÿπÿ®ŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ŸÑŸÖŸàÿßÿµŸÑÿ© ÿßŸÑŸÑÿπÿ®ÿ©.",
            noQuestions: "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ÿ≥ÿ¶ŸÑÿ© ÿµÿßŸÑÿ≠ÿ© ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿÆŸäÿßÿ±ÿßÿ™. ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©.",
            notEnoughQuestions:
              "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÉÿßŸÅŸäÿ© ŸÑŸÄ {totalRounds} ÿ¨ŸàŸÑÿßÿ™ ŸÖÿπ {playerCount} ŸÑÿßÿπÿ®ŸäŸÜ",
            gameInitError: "ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑŸÑÿπÿ®ÿ©.",
            gameDataError: "ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÑÿπÿ®ÿ©.",
            timeUp: "ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™! ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©.",
            roundsComplete: "ÿßŸÉÿ™ŸÖŸÑÿ™ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ¨ŸàŸÑÿßÿ™ {totalRounds}! ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©.",
            invalidPlayerData:
              "ÿÆÿ∑ÿ£: ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÑÿßÿπÿ® ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ© ŸÑŸÑÿ¨ŸàŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
          },
        },
      };

      // Function to get translated text
      function getTranslatedText(key, params = {}) {
        const [category, subKey] = key.split(".");
        let text;
        if (category && subKey) {
          text =
            translations[language][category]?.[subKey] ||
            translations.en[category]?.[subKey] ||
            subKey;
        } else {
          text = translations[language][key] || translations.en[key] || key;
        }
        for (const [paramKey, paramValue] of Object.entries(params)) {
          text = text.replace(`{${paramKey}}`, paramValue);
        }
        return text;
      }

      // Function to update UI text based on language
      function updateUIText() {
        dashboardTitle.textContent = getTranslatedText("dashboardTitle");
        playersHeader.textContent = getTranslatedText("playersHeader");
        chooseHeader.textContent = getTranslatedText("chooseHeader");
        submitAnswerBtn.textContent = getTranslatedText("submitAnswerBtn");
        nextRoundBtn.textContent = getTranslatedText("nextRoundBtn");
        roundProgress.textContent = getTranslatedText("roundProgress", {
          currentRound: currentRoundNumber || 1,
          totalRounds: questionLimit || 1,
        });
      }

      function loadQuestionsFromFirebase() {
        return new Promise((resolve) => {
          database
            .ref("admin/settings/languageCondition")
            .once("value", (snapshot) => {
              language = snapshot.val() === "ar" ? "ar" : "en";
              console.log(`Language set to: ${language}`);
              updateUIText();

              const questionLanguage = language === "en" ? "english" : "arabic";
              Promise.all([
                database
                  .ref(`admin/questions/${questionLanguage}/simple`)
                  .once("value"),
                database
                  .ref(`admin/questions/${questionLanguage}/sponsored`)
                  .once("value"),
              ])
                .then(([simpleSnap, sponsoredSnap]) => {
                  const simpleRaw = simpleSnap.val() || {};
                  const sponsoredRaw = sponsoredSnap.val() || {};
                  simpleQuestions = Object.values(simpleRaw)
                    .map((q) => ({
                      q: q.q || getTranslatedText("notifications.chooseOption"),
                      options:
                        Array.isArray(q.options) && q.options.length > 0
                          ? q.options
                          : ["Option 1", "Option 2"],
                      id: q.id || "",
                      createdAt: q.createdAt || 0,
                      language: q.language || questionLanguage,
                      type: q.type || "simple",
                    }))
                    .filter(
                      (q) =>
                        q.q && Array.isArray(q.options) && q.options.length > 0
                    );
                  sponsoredQuestions = Object.values(sponsoredRaw)
                    .map((q) => ({
                      q: q.q || getTranslatedText("notifications.chooseOption"),
                      options:
                        Array.isArray(q.options) && q.options.length > 0
                          ? q.options
                          : ["Option 1", "Option 2"],
                      id: q.id || "",
                      createdAt: q.createdAt || 0,
                      language: q.language || questionLanguage,
                      type: q.type || "sponsored",
                    }))
                    .filter(
                      (q) =>
                        q.q && Array.isArray(q.options) && q.options.length > 0
                    );
                  questionsLoaded = true;
                  console.log(
                    `Loaded ${simpleQuestions.length} simple and ${sponsoredQuestions.length} sponsored questions for ${questionLanguage}`
                  );
                  resolve();
                })
                .catch((error) => {
                  console.error(
                    `Error loading ${questionLanguage} questions:`,
                    error
                  );
                  simpleQuestions = [];
                  sponsoredQuestions = [];
                  questionsLoaded = true;
                  resolve();
                });
            })
            .catch((error) => {
              console.error("Error fetching language condition:", error);
              simpleQuestions = [];
              sponsoredQuestions = [];
              questionsLoaded = true;
              resolve();
            });
        });
      }

      function loadSponsoredAdsFromFirebase() {
        return new Promise((resolve) => {
          database
            .ref("admin/sponsored_ads")
            .once("value", (snapshot) => {
              const adsData = snapshot.val() || {};
              sponsoredAds = Object.values(adsData).filter(
                (ad) => ad.status === "active" && ad.image
              );
              console.log(`Loaded ${sponsoredAds.length} active sponsored ads`);
              resolve();
            })
            .catch((error) => {
              console.error("Error loading sponsored ads:", error);
              sponsoredAds = [];
              resolve();
            });
        });
      }

      function loadAdsFromFirebase() {
        database.ref("admin/ads").on(
          "value",
          (snapshot) => {
            const adsData = snapshot.val() || {};
            currentAds = Object.values(adsData).filter(
              (ad) => ad.status === "active"
            );
            console.log("Loaded active ads:", currentAds.length);
            if (currentAds.length === 0) {
              currentAds = [{ title: "Default Ad", content: "", url: "" }];
            }
            initializeAdRotation();
          },
          (error) => {
            console.error("Error loading ads:", error);
            currentAds = [{ title: "Default Ad", content: "", url: "" }];
            initializeAdRotation();
          }
        );
      }

      function initializeAdRotation() {
        if (currentAds.length > 0) {
          updateAdBanner();
          if (currentAds.length > 1) {
            setInterval(() => {
              currentAdIndex = (currentAdIndex + 1) % currentAds.length;
              updateAdBanner();
            }, 30000);
          }
        }
      }

      function updateAdBanner() {
        const adBanner = document.getElementById("adBanner");
        const adText = adBanner.querySelector(".ad-text");
        if (currentAds.length > 0) {
          const currentAd = currentAds[currentAdIndex];
          adText.textContent = currentAd.content;
          if (currentAd.url) {
            adBanner.style.cursor = "pointer";
            adBanner.onclick = () => window.open(currentAd.url, "_blank");
          } else {
            adBanner.style.cursor = "default";
            adBanner.onclick = null;
          }
        }
      }

      function initializeQuestionSequence() {
        const totalQuestionsNeeded = questionLimit * playerCount;
        const numSponsored = Math.floor(totalQuestionsNeeded / 5);
        questionSequence = new Array(totalQuestionsNeeded).fill("simple");
        usedSimpleQuestions = [];
        usedSponsoredQuestions = [];
        if (numSponsored > 0 && sponsoredQuestions.length > 0) {
          const step = Math.floor(totalQuestionsNeeded / numSponsored);
          for (let i = 0; i < numSponsored; i++) {
            let position = i * step + Math.floor(step / 2);
            if (position >= totalQuestionsNeeded) {
              position = totalQuestionsNeeded - 1;
            }
            questionSequence[position] = "sponsored";
          }
        }
        console.log("Question sequence:", questionSequence);
      }

      Promise.all([
        loadQuestionsFromFirebase(),
        loadAdsFromFirebase(),
        loadSponsoredAdsFromFirebase(),
      ])
        .then(() => {
          console.log("All game data loaded");
          Promise.all([
            gameRef.child("questionLimit").once("value"),
            gameRef.child("host").once("value"),
            gameRef.child("players").once("value"),
          ])
            .then(([questionSnap, hostSnap, playersSnap]) => {
              questionLimit = questionSnap.val() || 1;
              if (questionLimit < 1) {
                console.warn("Invalid questionLimit, defaulting to 1");
                questionLimit = 1;
              }
              questionLimitLoaded = true;

              hostName = hostSnap.val();
              const players = playersSnap.val() || {};
              playerCount = Object.keys(players).length;
              if (playerCount < 2) {
                console.warn(
                  `Minimum 2 players required, found ${playerCount}`
                );
                alert(getTranslatedText("notifications.minPlayers"));
                endGameDueToInvalidQuestions();
                return;
              }

              playerOrder = Object.keys(players).sort();
              playerOrder = [
                hostName,
                ...playerOrder.filter((p) => p !== hostName),
              ];
              gameRef.child("playerOrder").set(playerOrder);
              roundTargetPlayers = [hostName, ...playerOrder.slice(1)];
              gameRef.child("roundTargetPlayers").set(roundTargetPlayers);

              const totalQuestionsNeeded = questionLimit * playerCount;
              if (
                simpleQuestions.length + sponsoredQuestions.length <
                totalQuestionsNeeded
              ) {
                console.warn(
                  `Not enough questions for ${totalQuestionsNeeded} actions`
                );
                alert(
                  getTranslatedText("notifications.notEnoughQuestions", {
                    totalRounds: questionLimit,
                    playerCount,
                  })
                );
                endGameDueToInvalidQuestions();
                return;
              }

              gameDuration = questionLimit * playerCount * 20;
              roundProgress.textContent = getTranslatedText("roundProgress", {
                currentRound: 1,
                totalRounds: questionLimit,
              });
              document.getElementById("timer").textContent =
                formatTime(gameDuration);
              initializeQuestionSequence();

              gameRef
                .child("points")
                .remove()
                .then(() => {
                  const initialPoints = {};
                  playerOrder.forEach((player) => {
                    initialPoints[player] = 0;
                  });
                  gameRef.child("points").set(initialPoints);
                });

              if (simpleQuestions.length > 0 || sponsoredQuestions.length > 0) {
                initializeGlobalTimer();
                if (savedPlayerName === hostName) {
                  nextActionTurn();
                }
              } else {
                endGameDueToInvalidQuestions();
              }
            })
            .catch((error) => {
              console.error("Error initializing game:", error);
              alert(getTranslatedText("notifications.gameInitError"));
              endGameDueToInvalidQuestions();
            });
        })
        .catch((error) => {
          console.error("Error loading game data:", error);
          alert(getTranslatedText("notifications.gameDataError"));
          endGameDueToInvalidQuestions();
        });

      gameRef.child("gameEnded").on("value", (snapshot) => {
        if (snapshot.val() === true) {
          clearInterval(globalTimerInterval);
          window.location.href = `scoring.html?code=${accessCode}`;
        }
      });

      function initializeGlobalTimer() {
        const now = Date.now();
        gameRef.update({
          gameStartTime: now,
          gameDuration: gameDuration,
          roundCount: 1,
          actionNumber: 1,
          totalQuestionCount: 0,
          gameEnded: false,
        });
        gameStartTime = now;
        roundProgress.textContent = getTranslatedText("roundProgress", {
          currentRound: 1,
          totalRounds: questionLimit,
        });
        startGlobalTimer();
      }

      function startGlobalTimer() {
        clearInterval(globalTimerInterval);
        globalTimerInterval = setInterval(() => {
          updateGlobalTimer();
        }, 1000);
        gameRef.child("gameStartTime").on("value", (snap) => {
          if (snap.exists()) {
            gameStartTime = snap.val();
            updateGlobalTimer();
          }
        });
      }

      function updateGlobalTimer() {
        if (!gameStartTime || !gameDuration) return;
        const now = Date.now();
        const elapsed = Math.floor((now - gameStartTime) / 1000);
        const remaining = Math.max(0, gameDuration - elapsed);
        const timerElement = document.getElementById("timer");
        if (timerElement) {
          timerElement.textContent = formatTime(remaining);
        }
        if (remaining <= 0) {
          endGameDueToTimer();
        }
      }

      function endGameDueToTimer() {
        clearInterval(globalTimerInterval);
        alert(getTranslatedText("notifications.timeUp"));
        calculateAndSetWinner().then(() => {
          gameRef.update({ gameEnded: true });
        });
      }

      function formatTime(t) {
        const m = Math.floor(t / 60)
          .toString()
          .padStart(2, "0");
        const s = (t % 60).toString().padStart(2, "0");
        return `${m}:${s}`;
      }

      function calculateAndSetWinner() {
        return new Promise((resolve) => {
          gameRef.child("points").once("value", (pointsSnap) => {
            const points = pointsSnap.val() || {};
            if (Object.keys(points).length === 0) {
              gameRef
                .update({ winner: "No Winner", gameCompleted: true })
                .then(resolve);
              return;
            }
            let maxScore = -1;
            let winners = [];
            Object.entries(points).forEach(([player, score]) => {
              if (score > maxScore) {
                maxScore = score;
                winners = [player];
              } else if (score === maxScore) {
                winners.push(player);
              }
            });
            let winnerText =
              winners.length === 1 ? winners[0] : `Tie: ${winners.join(", ")}`;
            gameRef
              .update({
                winner: winnerText,
                gameCompleted: true,
                finalScores: points,
              })
              .then(resolve);
          });
        });
      }

      function renderPlayers(playersObj) {
        const playersContainer =
          document.getElementById("playersContainer") ||
          document.createElement("div");
        playersContainer.innerHTML = "";
        Object.keys(playersObj).forEach((name) => {
          const div = document.createElement("div");
          div.className = "player-box";
          div.textContent = name === hostName ? `${name} (Host)` : name;
          playersContainer.appendChild(div);
        });
      }

      function renderPoints(pointsObj) {
        pointsContainer.innerHTML = "";
        const sortedPlayers = Object.entries(pointsObj).sort(
          (a, b) => b[1] - a[1]
        );
        sortedPlayers.forEach(([player, score], index) => {
          const div = document.createElement("div");
          div.className = "player-score";
          if (index === 0) {
            div.classList.add("first-place");
          } else if (index === 1) {
            div.classList.add("second-place");
          } else if (index === 2) {
            div.classList.add("third-place");
          }
          div.innerHTML = `
            <span class="player-name">${player}</span>
            <span class="player-points">${score}</span>
          `;
          pointsContainer.appendChild(div);
        });
      }

      function allPlayersSubmittedForAction(selectedAnswers) {
        if (!selectedAnswers) return false;
        const submittedPlayers = Object.keys(selectedAnswers);
        return playerOrder.every((player) => submittedPlayers.includes(player));
      }

      function awardPoints(actionNumber, selectedAnswers, selectedPlayer) {
        const notifications = {};
        const selectedAnswer = selectedAnswers[selectedPlayer];

        console.log("playerOrder:", playerOrder);
        console.log("selectedPlayer:", selectedPlayer);
        const guessers = playerOrder.filter((p) => p !== selectedPlayer);
        console.log("target guessers:", guessers);
        console.log("selectedAnswers:", selectedAnswers);
        console.log("selectedAnswer:", selectedAnswer);

        if (!selectedAnswer) {
          console.warn(
            `No answer selected by selected player ${selectedPlayer} for Action ${actionNumber}`
          );
          notifications[`${selectedPlayer}_${actionNumber}`] = {
            message: getTranslatedText("notifications.noAnswerSelected"),
            type: "warning",
          };
          gameRef.child(`currentRound/notifications`).set(notifications);
          return;
        }

        guessers.forEach((guesser) => {
          const guesserAnswer = selectedAnswers[guesser];
          console.log(
            `Evaluating guesser ${guesser}: answer = ${guesserAnswer}, selectedAnswer = ${selectedAnswer}`
          );
          if (guesserAnswer && guesserAnswer === selectedAnswer) {
            // Award point only for correct guess
            gameRef
              .child("points")
              .child(guesser)
              .transaction((currentPoints) => {
                const newPoints = (currentPoints || 0) + 1;
                console.log(
                  `Awarded 1 point to ${guesser} for correct guess in Action ${actionNumber}, new total: ${newPoints}`
                );
                return newPoints;
              })
              .then(() => {
                notifications[`${guesser}_${actionNumber}`] = {
                  message: getTranslatedText("notifications.correctGuess", {
                    player: guesser,
                  }),
                  type: "success",
                };
              })
              .catch((error) => {
                console.error(
                  `Error awarding point to ${guesser} for Action ${actionNumber}:`,
                  error
                );
                notifications[`${guesser}_${actionNumber}`] = {
                  message: getTranslatedText(
                    "notifications.errorUpdatingPoints",
                    {
                      player: guesser,
                    }
                  ),
                  type: "warning",
                };
              });
          } else {
            // No points for incorrect or no guess
            console.log(
              `No points awarded to ${guesser} for Action ${actionNumber}: ${
                guesserAnswer ? "incorrect guess" : "no guess submitted"
              }`
            );
            notifications[`${guesser}_${actionNumber}`] = {
              message: guesserAnswer
                ? getTranslatedText("notifications.wrongGuess")
                : getTranslatedText("notifications.noGuessSubmitted"),
              type: "warning",
            };
          }
        });

        notifications[`${selectedPlayer}_${actionNumber}`] = {
          message: getTranslatedText("notifications.selectedPlayerComplete"),
          type: "info",
        };

        gameRef
          .child(`currentRound/notifications`)
          .set(notifications)
          .then(() => {
            console.log(
              `Points awarded and notifications set for Action ${actionNumber} in Round ${currentRoundNumber}`
            );
          })
          .catch((error) => {
            console.error(
              `Error setting notifications for Action ${actionNumber}:`,
              error
            );
            alert(getTranslatedText("notifications.errorNotifications"));
          });
      }

      function showNotification(message, type) {
        const notification = document.createElement("div");
        notification.className = `notification ${type}`;
        notification.textContent = message;
        document
          .getElementById("notificationContainer")
          .appendChild(notification);
        setTimeout(() => notification.remove(), 5000);
      }

      function getQuestionForAction() {
        const questionIndex = totalQuestionCount;
        if (questionIndex >= questionSequence.length) {
          console.error("Question index out of bounds");
          return {
            q: getTranslatedText("notifications.chooseOption"),
            options: ["Option 1", "Option 2"],
          };
        }

        const questionType = questionSequence[questionIndex] || "simple";
        let q;
        let backgroundImage;
        const fallbackImage = "gallary/design-1.png";

        if (
          questionType === "sponsored" &&
          sponsoredQuestions.length > usedSponsoredQuestions.length
        ) {
          const availableSponsored = sponsoredQuestions.filter(
            (q) =>
              !usedSponsoredQuestions.includes(q.q) &&
              q.options &&
              q.options.length > 0
          );
          if (availableSponsored.length > 0) {
            q =
              availableSponsored[
                Math.floor(Math.random() * availableSponsored.length)
              ];
            usedSponsoredQuestions.push(q.q);
            backgroundImage =
              sponsoredAds.length > 0
                ? sponsoredAds[Math.floor(Math.random() * sponsoredAds.length)]
                    .image
                : fallbackImage;
            console.log(
              "Selected sponsored question:",
              q,
              "Background:",
              backgroundImage
            );
          } else {
            q = getSimpleQuestion();
            backgroundImage =
              defaultBackgrounds[
                Math.floor(Math.random() * defaultBackgrounds.length)
              ];
            console.log(
              "No more valid sponsored questions, using simple question:",
              q
            );
          }
        } else {
          q = getSimpleQuestion();
          backgroundImage =
            defaultBackgrounds[
              Math.floor(Math.random() * defaultBackgrounds.length)
            ];
          console.log("Selected simple question:", q);
        }

        if (!q || !q.options || q.options.length === 0) {
          console.error("Selected question is invalid");
          return {
            q: getTranslatedText("notifications.chooseOption"),
            options: ["Option 1", "Option 2"],
            backgroundImage,
          };
        }

        return { ...q, backgroundImage };
      }

      function getSimpleQuestion() {
        const availableSimple = simpleQuestions.filter(
          (q) =>
            !usedSimpleQuestions.includes(q.q) &&
            q.options &&
            q.options.length > 0
        );
        if (availableSimple.length === 0) {
          usedSimpleQuestions = [];
          console.log("Reset used simple questions");
        }
        const finalSimpleQuestions = simpleQuestions.filter(
          (q) =>
            !usedSimpleQuestions.includes(q.q) &&
            q.options &&
            q.options.length > 0
        );
        if (finalSimpleQuestions.length === 0) {
          console.error("No valid simple questions available");
          return {
            q: getTranslatedText("notifications.chooseOption"),
            options: ["Option 1", "Option 2"],
          };
        }
        const q =
          finalSimpleQuestions[
            Math.floor(Math.random() * finalSimpleQuestions.length)
          ];
        usedSimpleQuestions.push(q.q);
        return q;
      }

      function nextActionTurn() {
        if (playerCount < 2) {
          console.warn(`Minimum 2 players required, found ${playerCount}`);
          alert(getTranslatedText("notifications.minPlayersContinue"));
          endGameDueToInvalidQuestions();
          return;
        }

        if (
          !questionsLoaded ||
          (simpleQuestions.length === 0 && sponsoredQuestions.length === 0)
        ) {
          console.log("Questions not loaded yet");
          if (!questionsLoaded) {
            loadQuestionsFromFirebase().then(() => {
              const totalQuestionsNeeded = questionLimit * playerCount;
              if (
                simpleQuestions.length + sponsoredQuestions.length <
                totalQuestionsNeeded
              ) {
                console.warn(
                  `Not enough questions for ${totalQuestionsNeeded} actions`
                );
                alert(
                  getTranslatedText("notifications.notEnoughQuestions", {
                    totalRounds: questionLimit,
                    playerCount,
                  })
                );
                endGameDueToInvalidQuestions();
                return;
              }
              nextActionTurn();
            });
          } else {
            alert(getTranslatedText("notifications.noQuestions"));
            endGameDueToInvalidQuestions();
          }
          return;
        }

        if (questionSequence.length === 0) {
          initializeQuestionSequence();
        }

        if (currentRoundNumber === 0 && currentTurnNumber === 1) {
          if (questionLimitLoaded) {
            initializeGlobalTimer();
          } else {
            gameRef.child("questionLimit").once("value", (snap) => {
              questionLimit = snap.val() || 1;
              if (questionLimit < 1) {
                console.warn("Invalid questionLimit, defaulting to 1");
                questionLimit = 1;
              }
              gameDuration = questionLimit * playerCount * 20;
              initializeGlobalTimer();
            });
          }
        }

        // Clear previous action's UI
        optionsContainer.innerHTML = "";
        questionSectionprime.innerHTML = "";
        submitAnswerBtn.classList.add("d-none");
        selectedOption = null;

        const selectedPlayer = roundTargetPlayers[currentTurnNumber - 1];
        const q = getQuestionForAction();

        const actionData = {};
        actionData[currentTurnNumber] = {
          question: q.q || getTranslatedText("notifications.chooseOption"),
          options: q.options || ["Option 1", "Option 2"],
          selectedPlayer: selectedPlayer,
          selectedAnswers: {},
          backgroundImage: q.backgroundImage,
        };

        gameRef
          .child("currentRound")
          .update({
            roundNumber: currentRoundNumber,
            actionNumber: currentTurnNumber,
            actionData: actionData,
            notifications: {},
            pointsAwarded: false,
          })
          .then(() => {
            totalQuestionCount++;
            gameRef.child("totalQuestionCount").set(totalQuestionCount);
            console.log(
              `Turn ${currentTurnNumber}/${playerCount} started for Round ${currentRoundNumber}, Question ${totalQuestionCount}`
            );
            if (savedPlayerName === hostName) {
              nextRoundBtn.classList.toggle(
                "d-none",
                currentRoundNumber >= questionLimit ||
                  currentTurnNumber < playerCount
              );
            }

            gameRef
              .child(`currentRound/actionData/${currentTurnNumber}`)
              .once("value", (snapshot) => {
                if (!snapshot.exists()) {
                  console.error(
                    `Action data for Turn ${currentTurnNumber} not found in Firebase`
                  );
                  alert(getTranslatedText("notifications.errorActionData"));
                  return;
                }

                const selectedAnswersRef = gameRef.child(
                  `currentRound/actionData/${currentTurnNumber}/selectedAnswers`
                );
                console.log(
                  `Monitoring submissions for Turn ${currentTurnNumber} at ${selectedAnswersRef.toString()}`
                );

                let submissionListener = selectedAnswersRef.on(
                  "value",
                  (snapshot) => {
                    const selectedAnswers = snapshot.val() || {};
                    console.log(
                      `Submissions for Turn ${currentTurnNumber}:`,
                      selectedAnswers
                    );
                    if (allPlayersSubmittedForAction(selectedAnswers)) {
                      selectedAnswersRef.off("value", submissionListener);
                      gameRef
                        .child("currentRound/pointsAwarded")
                        .once("value", (snap) => {
                          const pointsAwarded = snap.val() || false;
                          console.log(
                            `Points awarded status for Turn ${currentTurnNumber}:`,
                            pointsAwarded
                          );
                          if (!pointsAwarded) {
                            awardPoints(
                              currentTurnNumber,
                              selectedAnswers,
                              selectedPlayer
                            );
                            gameRef
                              .child("currentRound/pointsAwarded")
                              .set(true)
                              .then(() => {
                                selectedAnswersRef
                                  .remove()
                                  .then(() => {
                                    console.log(
                                      `Cleared selectedAnswers for Turn ${currentTurnNumber}`
                                    );
                                    if (currentTurnNumber < playerCount) {
                                      proceedToNextAction();
                                    } else {
                                      if (savedPlayerName === hostName) {
                                        nextRoundBtn.classList.remove("d-none");
                                        nextRoundBtn.disabled = false;
                                        console.log(
                                          `Turn ${currentTurnNumber} complete, Next Round button enabled for host`
                                        );
                                      } else {
                                        console.log(
                                          `Turn ${currentTurnNumber} complete, waiting for host to start next round`
                                        );
                                      }
                                    }
                                  })
                                  .catch((error) => {
                                    console.error(
                                      `Error clearing selectedAnswers for Turn ${currentTurnNumber}:`,
                                      error
                                    );
                                    alert(
                                      getTranslatedText(
                                        "notifications.errorActionData"
                                      )
                                    );
                                  });
                              })
                              .catch((error) => {
                                console.error(
                                  `Error setting pointsAwarded for Turn ${currentTurnNumber}:`,
                                  error
                                );
                                alert(
                                  getTranslatedText(
                                    "notifications.errorActionData"
                                  )
                                );
                              });
                          }
                        })
                        .catch((error) => {
                          console.error(
                            `Error checking pointsAwarded for Turn ${currentTurnNumber}:`,
                            error
                          );
                          alert(
                            getTranslatedText("notifications.errorActionData")
                          );
                        });
                    }
                  },
                  (error) => {
                    console.error(
                      `Error monitoring submissions for Turn ${currentTurnNumber}:`,
                      error
                    );
                    setTimeout(() => {
                      submissionListener = selectedAnswersRef.on(
                        "value",
                        (snapshot) => {
                          const selectedAnswers = snapshot.val() || {};
                          console.log(
                            `Retry submissions for Turn ${currentTurnNumber}:`,
                            selectedAnswers
                          );
                          if (allPlayersSubmittedForAction(selectedAnswers)) {
                            selectedAnswersRef.off("value", submissionListener);
                          }
                        },
                        (retryError) => {
                          console.error(
                            `Retry failed for submission listener:`,
                            retryError
                          );
                          alert(
                            getTranslatedText("notifications.errorSubmissions")
                          );
                        }
                      );
                    }, 1000);
                  }
                );
              })
              .catch((error) => {
                console.error(
                  `Error verifying actionData for Turn ${currentTurnNumber}:`,
                  error
                );
                alert(getTranslatedText("notifications.errorActionData"));
              });
          })
          .catch((error) => {
            console.error("Error setting action in Firebase:", error);
            setTimeout(() => {
              gameRef
                .child("currentRound")
                .update({
                  roundNumber: currentRoundNumber,
                  actionNumber: currentTurnNumber,
                  actionData: actionData,
                  notifications: {},
                  pointsAwarded: false,
                })
                .then(() => {
                  console.log(
                    `Retry successful: Turn ${currentTurnNumber} initialized`
                  );
                  totalQuestionCount++;
                  gameRef.child("totalQuestionCount").set(totalQuestionCount);
                  nextActionTurn();
                })
                .catch((retryError) => {
                  console.error(
                    `Retry failed for action initialization:`,
                    retryError
                  );
                  alert(getTranslatedText("notifications.errorActionInit"));
                });
            }, 1000);
          });
      }

      function proceedToNextAction() {
        currentTurnNumber++;
        gameRef
          .child("currentRound")
          .update({
            roundNumber: currentRoundNumber,
            actionNumber: currentTurnNumber,
            actionData: {},
            notifications: {},
            pointsAwarded: false,
          })
          .then(() => {
            console.log(`Turn ${currentTurnNumber} initialized in Firebase`);
            nextActionTurn();
          })
          .catch((error) => {
            console.error(
              `Error updating actionNumber to ${currentTurnNumber}:`,
              error
            );
            setTimeout(() => {
              gameRef
                .child("currentRound")
                .update({
                  roundNumber: currentRoundNumber,
                  actionNumber: currentTurnNumber,
                  actionData: {},
                  notifications: {},
                  pointsAwarded: false,
                })
                .then(() => {
                  console.log(
                    `Retry successful: Turn ${currentTurnNumber} initialized`
                  );
                  nextActionTurn();
                })
                .catch((retryError) => {
                  console.error(
                    `Retry failed for actionNumber update:`,
                    retryError
                  );
                  alert(getTranslatedText("notifications.errorActionAdvance"));
                });
            }, 1000);
          });
      }

      function startNextRound() {
        currentTurnNumber = 1;
        currentRoundNumber++;
        if (currentRoundNumber > questionLimit) {
          endGameDueToRoundLimit();
          return;
        }
        console.log(`Starting Round ${currentRoundNumber}`);
        roundProgress.textContent = getTranslatedText("roundProgress", {
          currentRound: currentRoundNumber,
          totalRounds: questionLimit,
        });
        roundTargetPlayers = [
          hostName,
          ...playerOrder.filter((p) => p !== hostName),
        ];

        // Ensure roundTargetPlayers is a valid array
        if (
          !Array.isArray(roundTargetPlayers) ||
          roundTargetPlayers.length === 0
        ) {
          console.error(
            "Invalid roundTargetPlayers array:",
            roundTargetPlayers
          );
          alert(getTranslatedText("notifications.invalidPlayerData"));
          return;
        }

        // Update currentRound data first
        gameRef
          .child("currentRound")
          .update({
            roundNumber: currentRoundNumber,
            actionNumber: currentTurnNumber,
            actionData: {},
            notifications: {},
            pointsAwarded: false,
          })
          .then(() => {
            // Retry mechanism for updating roundTargetPlayers
            function updateRoundData(attempt = 1) {
              gameRef
                .update({
                  roundCount: currentRoundNumber,
                  roundTargetPlayers: roundTargetPlayers,
                })
                .then(() => {
                  console.log(
                    `Round ${currentRoundNumber} initialized in Firebase`
                  );
                  nextActionTurn();
                })
                .catch((error) => {
                  console.error(
                    `Error updating roundTargetPlayers for Round ${currentRoundNumber} (Attempt ${attempt}):`,
                    error
                  );
                  if (attempt < 3) {
                    console.log(
                      `Retrying update for Round ${currentRoundNumber}, attempt ${
                        attempt + 1
                      }`
                    );
                    setTimeout(() => updateRoundData(attempt + 1), 1000);
                  } else {
                    console.error(
                      `Failed to update roundTargetPlayers after ${attempt} attempts`
                    );
                    alert(
                      getTranslatedText(
                        "notifications.errorRoundAdvanceRetries"
                      )
                    );
                  }
                });
            }

            updateRoundData();
          })
          .catch((error) => {
            console.error(
              `Error updating roundCount to ${currentRoundNumber}:`,
              error
            );
            setTimeout(() => {
              gameRef
                .child("currentRound")
                .update({
                  roundNumber: currentRoundNumber,
                  actionNumber: currentTurnNumber,
                  actionData: {},
                  notifications: {},
                  pointsAwarded: false,
                })
                .then(() => {
                  function updateRoundData(attempt = 1) {
                    gameRef
                      .update({
                        roundCount: currentRoundNumber,
                        roundTargetPlayers: roundTargetPlayers,
                      })
                      .then(() => {
                        console.log(
                          `Retry successful: Round ${currentRoundNumber} initialized`
                        );
                        nextActionTurn();
                      })
                      .catch((retryError) => {
                        console.error(
                          `Retry failed for roundTargetPlayers update (Attempt ${attempt}):`,
                          retryError
                        );
                        if (attempt < 3) {
                          console.log(
                            `Retrying update for Round ${currentRoundNumber}, attempt ${
                              attempt + 1
                            }`
                          );
                          setTimeout(() => updateRoundData(attempt + 1), 1000);
                        } else {
                          console.error(
                            `Failed to update roundTargetPlayers after ${attempt} attempts`
                          );
                          alert(
                            getTranslatedText(
                              "notifications.errorRoundAdvanceRetries"
                            )
                          );
                        }
                      });
                  }
                  updateRoundData();
                })
                .catch((retryError) => {
                  console.error(
                    `Retry failed for roundCount update:`,
                    retryError
                  );
                  alert(
                    getTranslatedText("notifications.errorRoundAdvanceRetries")
                  );
                });
            }, 1000);
          });
      }

      function endGameDueToRoundLimit() {
        clearInterval(globalTimerInterval);
        alert(
          getTranslatedText("notifications.roundsComplete", {
            totalRounds: questionLimit,
          })
        );
        calculateAndSetWinner().then(() => {
          gameRef.update({ gameEnded: true });
        });
      }

      function endGameDueToInvalidQuestions() {
        clearInterval(globalTimerInterval);
        alert(getTranslatedText("notifications.noQuestions"));
        calculateAndSetWinner().then(() => {
          gameRef.update({ gameEnded: true });
        });
      }

      gameRef.child("players").on("value", (snapshot) => {
        const players = snapshot.val();
        if (players) {
          renderPlayers(players);
          playerCount = Object.keys(players).length;
          if (playerCount < 2) {
            console.warn(`Minimum 2 players required, found ${playerCount}`);
            alert(getTranslatedText("notifications.minPlayersContinue"));
            endGameDueToInvalidQuestions();
            return;
          }
          playerOrder = Object.keys(players).sort();
          playerOrder = [
            hostName,
            ...playerOrder.filter((p) => p !== hostName),
          ];
          if (savedPlayerName === hostName) {
            gameRef.child("playerOrder").set(playerOrder);
            roundTargetPlayers = [hostName, ...playerOrder.slice(1)];
            gameRef.child("roundTargetPlayers").set(roundTargetPlayers);
          }
        }
      });

      gameRef.child("points").on("value", (snapshot) => {
        const points = snapshot.val() || {};
        renderPoints(points);
      });

      gameRef.child("roundTargetPlayers").on("value", (snapshot) => {
        const targetPlayers = snapshot.val();
        if (targetPlayers) {
          roundTargetPlayers = targetPlayers;
        }
      });

      gameRef.child("playerOrder").on("value", (snapshot) => {
        const order = snapshot.val();
        if (order) {
          playerOrder = order;
        }
      });

      gameRef.child("currentRound").on("value", (snapshot) => {
        const roundData = snapshot.val();
        if (!roundData) return;

        currentTurnNumber = roundData.actionNumber || 1;
        currentRoundNumber = roundData.roundNumber || 1;

        roundProgress.textContent = getTranslatedText("roundProgress", {
          currentRound: currentRoundNumber,
          totalRounds: questionLimit,
        });

        if (roundData.pointsAwarded) {
          questionSectionprime.innerHTML = `<p class="waiting-text">${getTranslatedText(
            "waitingTextComplete"
          )}</p>`;
          optionsContainer.innerHTML = "";
          submitAnswerBtn.classList.add("d-none");
          waitingHeader.style.display = "none";
          chooseHeader.style.display = "none";
          if (
            savedPlayerName === hostName &&
            currentTurnNumber === playerCount
          ) {
            nextRoundBtn.classList.remove("d-none");
            nextRoundBtn.disabled = false;
          }
          if (roundData.notifications) {
            const key = `${savedPlayerName}_${currentTurnNumber}`;
            if (roundData.notifications[key]) {
              const { message, type } = roundData.notifications[key];
              showNotification(message, type);
            }
          }
          return;
        }

        const actionData =
          roundData.actionData && roundData.actionData[currentTurnNumber];
        if (!actionData) {
          optionsContainer.innerHTML = "";
          questionSectionprime.innerHTML = "";
          submitAnswerBtn.classList.add("d-none");
          waitingHeader.style.display = "none";
          chooseHeader.style.display = "none";
          return;
        }

        const question =
          actionData.question ||
          getTranslatedText("notifications.chooseOption");
        const options = actionData.options || ["Option 1", "Option 2"];
        const selectedPlayer = actionData.selectedPlayer || "";
        const isSelected = savedPlayerName === selectedPlayer;
        const hasSubmitted =
          actionData.selectedAnswers &&
          actionData.selectedAnswers[savedPlayerName];
        const selectedHasSubmitted =
          actionData.selectedAnswers &&
          actionData.selectedAnswers[selectedPlayer];

        if (actionData.backgroundImage) {
          document.body.style.backgroundImage = `url('${actionData.backgroundImage}')`;
        } else {
          document.body.style.backgroundImage = `url('${
            defaultBackgrounds[
              Math.floor(Math.random() * defaultBackgrounds.length)
            ]
          }')`;
        }

        waitingHeader.textContent = getTranslatedText("waitingHeader", {
          selectedPlayer,
        });
        chooseHeader.textContent = getTranslatedText("chooseHeader");

        optionsContainer.innerHTML = "";
        options.forEach((opt) => {
          const btn = document.createElement("button");
          btn.className = "btn btn-outline-primary guess-option";
          btn.textContent = opt;
          btn.disabled = hasSubmitted || (!isSelected && !selectedHasSubmitted);
          btn.onclick = () => {
            if (hasSubmitted || (!isSelected && !selectedHasSubmitted)) {
              console.log(
                "Cannot select: already submitted or Selected Player has not chosen"
              );
              return;
            }
            console.log("Option selected:", opt);
            selectedOption = opt;
            document
              .querySelectorAll(".guess-option")
              .forEach((b) => (b.disabled = true));
            submitAnswerBtn.classList.remove("d-none");
            waitingHeader.style.display = "none";
            chooseHeader.style.display = "none";
          };
          optionsContainer.appendChild(btn);
        });

        if (isSelected) {
          questionSectionprime.innerHTML = `<p class="waiting-text">${getTranslatedText(
            "waitingTextSelected"
          )}</p>`;
          waitingHeader.style.display = "none";
          chooseHeader.style.display = "block";
        } else if (!selectedHasSubmitted) {
          questionSectionprime.innerHTML = `<p class="waiting-text">${getTranslatedText(
            "waitingTextOthers",
            { selectedPlayer }
          )}</p>`;
          waitingHeader.style.display = "block";
          chooseHeader.style.display = "none";
        } else {
          questionSectionprime.innerHTML = `<p class="waiting-text">${getTranslatedText(
            "waitingTextSelected"
          )}</p>`;
          waitingHeader.style.display = "none";
          chooseHeader.style.display = "block";
        }

        if (roundData.notifications) {
          const key = `${savedPlayerName}_${currentTurnNumber}`;
          if (roundData.notifications[key]) {
            const { message, type } = roundData.notifications[key];
            showNotification(message, type);
          }
        }

        if (savedPlayerName === hostName) {
          nextRoundBtn.classList.toggle(
            "d-none",
            currentRoundNumber >= questionLimit ||
              currentTurnNumber < playerCount
          );
        }
      });

      submitAnswerBtn.addEventListener("click", () => {
        if (selectedOption) {
          console.log(
            `Submitting answer for ${savedPlayerName} in Turn ${currentTurnNumber}: ${selectedOption}`
          );
          gameRef
            .child(
              `currentRound/actionData/${currentTurnNumber}/selectedAnswers`
            )
            .child(savedPlayerName)
            .set(selectedOption)
            .then(() => {
              console.log(
                `Answer submitted for ${savedPlayerName} in Turn ${currentTurnNumber}`
              );
              submitAnswerBtn.classList.add("d-none");
              selectedOption = null;
              waitingHeader.style.display = "none";
              chooseHeader.style.display = "none";
            })
            .catch((error) => {
              console.error(
                `Error submitting answer for ${savedPlayerName} in Turn ${currentTurnNumber}:`,
                error
              );
              alert(getTranslatedText("notifications.errorActionData"));
            });
        }
      });

      nextRoundBtn.addEventListener("click", () => {
        if (savedPlayerName === hostName) {
          console.log(`Next Round button clicked by host`);
          startNextRound();
        }
      });
    </script>


<button id="micBtn" style="
position: fixed;
bottom: 20px;
right: 20px;
z-index: 999;
width: 60px;
height: 60px;
border-radius: 10px;
background-color: #20BB58;
color: white;
border: 2px solid white;
/* Sharp top-left shadow, no blur */
box-shadow: -6px -6px 0 rgba(0,0,0,0.8);
display: flex;
align-items: center;
justify-content: center;
font-size: 24px;
cursor: pointer;
transition: all 0.2s ease;
">
<i id="micIcon" class="bi bi-mic-mute-fill"></i>
</button>

<button id="speakerBtn" style="
position: fixed;
bottom: 90px;
right: 20px;
z-index: 999;
width: 60px;
height: 60px;
border-radius: 10px;
background-color: #20BB58;
color: white;
border: 2px solid white;
box-shadow: -6px -6px 0 rgba(0,0,0,0.8); /* sharp top-left shadow */
display: flex;
align-items: center;
justify-content: center;
font-size: 24px;
cursor: pointer;
transition: all 0.2s ease;
">
<i id="speakerIcon" class="bi bi-volume-up-fill"></i>
</button>

<!-- 
<script>
  const roomId = localStorage.getItem("roomId");
  const myPeerId = localStorage.getItem("myPeerId");

  // Listen for peers in this room
  const roomRef = firebase.database().ref("rooms/" + roomId + "/peers");

  roomRef.on("value", snapshot => {
    const peers = Object.keys(snapshot.val() || {});
    const otherId = peers.find(pid => pid !== myPeerId);

    if (otherId) {
      console.log("Connecting to peer:", otherId);
      connectToPeer(otherId); // this is from voiceChat.js
    }
  });
</script> -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script src="voiceChat.js"></script>
<script>
  // Initialize PeerJS on this page
  const roomId = localStorage.getItem("roomId");

  // Create a new Peer instance (or reuse ID if you want persistent across reloads)
  const peer = new Peer(); // let voiceChat.js pick this up as window.peer

  peer.on("open", id => {
    console.log("My Peer ID on this page:", id);

    const roomRef = firebase.database().ref("rooms/" + roomId + "/peers");
    roomRef.child(id).set(true);

    peer.on("disconnected", () => {
      roomRef.child(id).remove();
    });

    // Now start listening for peers and connecting
    if (window.voiceChatInitialized) {
      // voiceChat.js should automatically pick up window.localStream and call connections
    }
  });
</script>
<script src="voiceChat.js"></script>

  </body>



</html>
